using System.Text;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using VerifyCS = Moq.AutoMocker.Generators.Tests.CSharpSourceGeneratorVerifier<Moq.AutoMocker.Generators.KeyedServicesExtensionSourceGenerator>;


namespace Moq.AutoMocker.Generators.Tests;

[TestClass]
public class KeyedServicesGeneratorTests
{
    private const string ExpectedKeyedServicesGeneratedFile = """
        #nullable enable
        // Generated by Moq.AutoMocker.Generators.KeyedServicesExtensionSourceGenerator.
        // Licensed under the MIT License. See LICENSE in the project root for license information.
        namespace Moq.AutoMock
        {
            using System;
            using System.Collections.Concurrent;
            using System.Diagnostics.CodeAnalysis;
            using System.Linq;
            using System.Reflection;
            using Microsoft.Extensions.DependencyInjection;
            using Moq.AutoMock.Resolvers;
        
            /// <summary>
            /// This class provides extension methods for interacting with keyed services in an <see cref="AutoMocker"/> instance.
            /// </summary>
            static partial class AutoMockerKeyedServicesExtensions
            {
                /// <summary>
                /// Registers a keyed service with the <see cref="AutoMocker"/> instance, allowing it to be resolved via <see cref="IKeyedServiceProvider"/>.
                /// </summary>
                /// <param name="mocker">The <see cref="AutoMocker"/> instance.</param>
                /// <param name="service">The service instance to register.</param>
                /// <param name="key">The service key to associate with the service.</param>
                /// <typeparam name="TService">The type of service being registered.</typeparam>
                /// <exception cref="ArgumentNullException">Thrown when <paramref name="mocker"/> is null.</exception>
                public static void WithKeyedService<TService>(this AutoMocker mocker, TService service, object? key)
                    where TService : class
                {
                    mocker.WithKeyedService<TService, TService>(service, key);
                }
        
                /// <summary>
                /// Registers a keyed service with the <see cref="AutoMocker"/> instance, allowing it to be resolved via <see cref="IKeyedServiceProvider"/>.
                /// </summary>
                /// <param name="mocker">The <see cref="AutoMocker"/> instance.</param>
                /// <param name="service">The service instance to register.</param>
                /// <param name="key">The service key to associate with the service.</param>
                /// <typeparam name="TService">The type of service being registered.</typeparam>
                /// <typeparam name="TImplementation">The implementation type of the service.</typeparam>
                /// <exception cref="ArgumentNullException">Thrown when <paramref name="mocker"/> is null.</exception>
                public static void WithKeyedService<TService, TImplementation>(this AutoMocker mocker, TImplementation service, object? key)
                    where TImplementation : class, TService
                {
                    ServiceProviderResolver resolver = GetResolver(mocker);
                    resolver.AddKeyedService<TService, TImplementation>(service, key);
                }
        
                /// <summary>
                /// Registers a keyed service with the <see cref="AutoMocker"/> instance that will be resolved lazily when requested.
                /// The service will be created using AutoMocker when first accessed.
                /// </summary>
                /// <param name="mocker">The <see cref="AutoMocker"/> instance.</param>
                /// <param name="key">The service key to associate with the service.</param>
                /// <typeparam name="TService">The type of service being registered.</typeparam>
                /// <exception cref="ArgumentNullException">Thrown when <paramref name="mocker"/> is null.</exception>
                public static void WithKeyedService<TService>(this AutoMocker mocker, object? key)
                    where TService : class
                {
                    mocker.WithKeyedService<TService, TService>(key);
                }
        
                /// <summary>
                /// Registers a keyed service with the <see cref="AutoMocker"/> instance that will be resolved lazily when requested.
                /// The service will be created using AutoMocker when first accessed.
                /// </summary>
                /// <param name="mocker">The <see cref="AutoMocker"/> instance.</param>
                /// <param name="key">The service key to associate with the service.</param>
                /// <typeparam name="TService">The type of service being registered.</typeparam>
                /// <typeparam name="TImplementation">The implementation type of the service.</typeparam>
                /// <exception cref="ArgumentNullException">Thrown when <paramref name="mocker"/> is null.</exception>
                public static void WithKeyedService<TService, TImplementation>(this AutoMocker mocker, object? key)
                    where TImplementation : class, TService
                {
                    ServiceProviderResolver resolver = GetResolver(mocker);
                    resolver.AddKeyedService<TService, TImplementation>(key);
                }
        
                private static ServiceProviderResolver GetResolver(AutoMocker mocker)
                {
                    ServiceProviderResolver? resolver = mocker.Resolvers.OfType<ServiceProviderResolver>().FirstOrDefault();
                    if (resolver is null)
                    {
                        resolver = new ServiceProviderResolver();
                        mocker.Resolvers.Insert(0, resolver);
                    }
                    return resolver;
                }
        
                private class ServiceProviderResolver : IMockResolver
                {
                    private ConcurrentDictionary<AutoMocker, AutoMockerServiceProvider> ServiceProviders { get; } = [];
        
                    private ConcurrentDictionary<ServiceIdentifier, object> Services { get; } = [];
        
                    public void Resolve(MockResolutionContext context)
                    {
                        if (context.RequestType == typeof(IServiceProvider) ||
                            context.RequestType == typeof(IKeyedServiceProvider))
                        {
                            context.Value = ServiceProviders.GetOrAdd(context.AutoMocker, x => new AutoMockerServiceProvider(x, Services));
                        }
                        ParameterInfo? parameterInfo = context.ObjectGraphContext.ParameterInfo;
                        if (parameterInfo != null)
                        {
                            var keyedAttribute = parameterInfo.GetCustomAttribute<FromKeyedServicesAttribute>();
                            if (keyedAttribute != null)
                            {
                                context.Value = ServiceProviders.GetOrAdd(context.AutoMocker, x => new AutoMockerServiceProvider(x, Services))
                                    .GetKeyedService(context.RequestType, keyedAttribute.Key);
                            }
                        }
                    }
        
                    public void AddKeyedService<TService, TImplementation>(TImplementation service, object? serviceKey)
                        where TImplementation : class, TService
                    {
                        ServiceIdentifier identifier = new(serviceKey, typeof(TService));
                        Services.AddOrUpdate(identifier, service, (id, value) => value);
                    }
        
                    public void AddKeyedService<TService>(object? serviceKey)
                        where TService : class
                    {
                        AddKeyedService<TService, TService>(serviceKey);
                    }
        
                    public void AddKeyedService<TService, TImplementation>(object? serviceKey)
                        where TImplementation : class, TService
                    {
                        ServiceIdentifier identifier = new(serviceKey, typeof(TService));
                        //The first parameter is just to avoid any collisions with registration since the type is private
                        Func<AutoMockerServiceProvider, AutoMocker, object> factory = (_, mocker) => mocker.CreateInstance<TImplementation>();
                        Services.AddOrUpdate(identifier, factory, (id, value) => value);
                    }
        
                    private class AutoMockerServiceProvider(AutoMocker mocker, ConcurrentDictionary<ServiceIdentifier, object> services) : IServiceProvider, IKeyedServiceProvider
                    {
                        public object? GetService(Type serviceType)
                        {
                            return GetService(new ServiceIdentifier(serviceType)) ?? mocker.Get(serviceType);
                        }
        
                        public object? GetKeyedService(Type serviceType, object? serviceKey)
                        {
                            return GetService(new ServiceIdentifier(serviceKey, serviceType));
                        }
        
                        public object GetRequiredKeyedService(Type serviceType, object? serviceKey)
                        {
                            return GetKeyedService(serviceType, serviceKey) ?? throw new InvalidOperationException($"Failed to resolve keyed service of type {serviceType.FullName} with key '{serviceKey}'");
                        }
        
                        private object? GetService(ServiceIdentifier serviceIdentifier)
                        {
                            if (services.TryGetValue(serviceIdentifier, out object? service))
                            {
                                if (service is Func<AutoMockerServiceProvider, AutoMocker, object> factory)
                                {
                                    return factory(this, mocker);
                                }
        
                                return service;
                            }
                            return null;
                        }
                    }
                }
        
                // https://github.com/dotnet/runtime/blob/41c9fa2d39a02d98cdead08e72f961e77b7888b0/src/libraries/Microsoft.Extensions.DependencyInjection/src/ServiceLookup/ServiceIdentifier.cs#L9
                private readonly struct ServiceIdentifier : IEquatable<ServiceIdentifier>
                {
                    public object? ServiceKey { get; }
        
                    public Type ServiceType { get; }
        
                    public ServiceIdentifier(Type serviceType)
                    {
                        ServiceType = serviceType;
                    }
        
                    public ServiceIdentifier(object? serviceKey, Type serviceType)
                    {
                        ServiceKey = serviceKey;
                        ServiceType = serviceType;
                    }
        
                    public static ServiceIdentifier FromDescriptor(ServiceDescriptor serviceDescriptor)
                        => new(serviceDescriptor.ServiceKey, serviceDescriptor.ServiceType);
        
                    public static ServiceIdentifier FromServiceType(Type type) => new(null, type);
        
                    public bool Equals(ServiceIdentifier other)
                    {
                        if (ServiceKey == null && other.ServiceKey == null)
                        {
                            return ServiceType == other.ServiceType;
                        }
                        else if (ServiceKey != null && other.ServiceKey != null)
                        {
                            return ServiceType == other.ServiceType && ServiceKey.Equals(other.ServiceKey);
                        }
                        return false;
                    }
        
                    public override bool Equals(object? obj)
                    {
                        return obj is ServiceIdentifier identifier && Equals(identifier);
                    }
        
                    public override int GetHashCode()
                    {
                        if (ServiceKey == null)
                        {
                            return ServiceType.GetHashCode();
                        }
                        unchecked
                        {
                            return (ServiceType.GetHashCode() * 397) ^ ServiceKey.GetHashCode();
                        }
                    }
        
                    public ServiceIdentifier GetGenericTypeDefinition() => new ServiceIdentifier(ServiceKey, ServiceType.GetGenericTypeDefinition());
        
                    public override string? ToString()
                    {
                        if (ServiceKey == null)
                        {
                            return ServiceType.ToString();
                        }
        
                        return $"({ServiceKey}, {ServiceType})";
                    }
                }
            }
        }
        """;

    [TestMethod]
    public async Task WhenDependencyInjectionAssemblyIsNotReferenced_NoGenerationOccurs()
    {
        await new VerifyCS.Test
        {
            TestCode = "",
            ReferenceDependencyInjection = false

        }.RunAsync(TestContext.CancellationToken);
    }

    [TestMethod]
    public async Task WhenDependencyInjectionAssemblyIsReferenced_ExtensionMethodIsGenerated()
    {
        await new VerifyCS.Test
        {
            CompilerDiagnostics = CompilerDiagnostics.None,
            ReferenceDependencyInjection = true,
            TestCode = "",
            TestState =
            {
                GeneratedSources =
                {
                    GetSourceFile(ExpectedKeyedServicesGeneratedFile, "AutoMockerKeyedServicesExtensions.g.cs")
                }
            }

        }.RunAsync(TestContext.CancellationToken);
    }

    [TestMethod]
    public async Task WhenGeneratorIsDisabled_NoGenerationOccurs()
    {
        var test = new VerifyCS.Test
        {
            ReferenceDependencyInjection = true,
            TestCode = ""
        };
        test.SetGlobalOption("build_property.EnableMoqAutoMockerKeyedServicesGenerator", "false");
        await test.RunAsync(TestContext.CancellationToken);
    }

    [TestMethod]
    public async Task WhenGeneratorIsExplicitlyEnabled_ExtensionMethodIsGenerated()
    {
        var test = new VerifyCS.Test
        {
            CompilerDiagnostics = CompilerDiagnostics.None,
            ReferenceDependencyInjection = true,
            TestCode = "",
            TestState =
            {
                GeneratedSources =
                {
                    GetSourceFile(ExpectedKeyedServicesGeneratedFile, "AutoMockerKeyedServicesExtensions.g.cs")
                }
            }
        };
        test.SetGlobalOption("build_property.EnableMoqAutoMockerKeyedServicesGenerator", "true");
        await test.RunAsync(TestContext.CancellationToken);
    }

    private static (string FileName, SourceText SourceText) GetSourceFile(string content, string fileName)
    {
        return (Path.Combine("Moq.AutoMocker.Generators", "Moq.AutoMocker.Generators.KeyedServicesExtensionSourceGenerator", fileName), SourceText.From(content, Encoding.UTF8));
    }

    public TestContext TestContext { get; set; }
}
