using Microsoft.CodeAnalysis.Text;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using VerifyCS = Moq.AutoMocker.Generators.Tests.CSharpSourceGeneratorVerifier<Moq.AutoMocker.Generators.FakeLoggingExtensionSourceGenerator>;
using Microsoft.CodeAnalysis.Testing;

namespace Moq.AutoMocker.Generators.Tests;

[TestClass]
public class FakeLoggingGeneratorTests
{
    private const string ExpectedFakeLoggingGeneratedFile = """
        #nullable enable
        // Generated by Moq.AutoMocker.Generators.FakeLoggingExtensionSourceGenerator.
        // Licensed under the MIT License. See LICENSE in the project root for license information.
        namespace Moq.AutoMock
        {
            using System;
            using Microsoft.Extensions.Logging;
            using Microsoft.Extensions.Logging.Testing;
            using Moq.AutoMock.Resolvers;

            /// <summary>
            /// This class provides extension methods for interacting with fake logging in an <see cref="AutoMocker"/> instance.
            /// </summary>
            static partial class AutoMockerFakeLoggingExtensions
            {
                /// <summary>
                /// This method sets up <see cref="AutoMocker"/> with fake logging services from Microsoft.Extensions.Logging.Testing,
                /// allowing logging interception and validation in testing scenarios.
                /// </summary>
                /// <param name="mocker">The <see cref="AutoMocker"/> instance.</param>
                /// <returns>The same <see cref="AutoMocker"/> instance passed as parameter, allowing chained calls.</returns>
                public static AutoMocker AddFakeLogging(this AutoMocker mocker)
                {
                    if (mocker == null)
                    {
                        throw new ArgumentNullException(nameof(mocker));
                    }

                    var provider = new FakeLoggerProvider();
                    var resolver = new FakeLoggerResolver(provider);
                    
                    // Find the CacheResolver and insert the FakeLoggerResolver after it
                    int cacheResolverIndex = -1;
                    for (int i = 0; i < mocker.Resolvers.Count; i++)
                    {
                        if (mocker.Resolvers[i] is CacheResolver)
                        {
                            cacheResolverIndex = i;
                            break;
                        }
                    }

                    if (cacheResolverIndex >= 0)
                    {
                        mocker.Resolvers.Insert(cacheResolverIndex + 1, resolver);
                    }
                    else
                    {
                        mocker.Resolvers.Insert(0, resolver);
                    }

                    mocker.Use(provider);
                    
                    return mocker;
                }

                private sealed class FakeLoggerResolver : IMockResolver
                {
                    private readonly FakeLoggerProvider _provider;

                    public FakeLoggerResolver(FakeLoggerProvider provider)
                    {
                        _provider = provider ?? throw new ArgumentNullException(nameof(provider));
                    }

                    public void Resolve(MockResolutionContext context)
                    {
                        if (context.RequestType == typeof(ILoggerFactory))
                        {
                            var loggerFactory = LoggerFactory.Create(b =>
                            {
                                b.SetMinimumLevel(LogLevel.Trace);
                                b.AddProvider(_provider);
                            });
                            context.Value = loggerFactory;
                        }
                        else if (context.RequestType.IsGenericType &&
                                context.RequestType.GetGenericTypeDefinition() == typeof(ILogger<>))
                        {
                            // Create a generic FakeLogger<T> for the requested type
                            var genericType = context.RequestType.GetGenericArguments()[0];
                            var fakeType = typeof(FakeLogger<>).MakeGenericType(genericType);

                            context.Value = Activator.CreateInstance(fakeType, _provider.Collector);
                        }
                        else if (context.RequestType == typeof(ILogger))
                        {
                            context.Value = _provider.CreateLogger("TestLogger");
                        }
                    }
                }
            }
        }
        """;

    [TestMethod]
    public async Task WhenFakeLoggingAssemblyIsNotReferenced_NoGenerationOccurs()
    {
        await new VerifyCS.Test
        {
            TestCode = "",
            ReferenceFakeLogging = false
        }.RunAsync();
    }

    [TestMethod]
    public async Task WhenFakeLoggingAssemblyIsReferenced_ExtensionMethodIsGenerated()
    {
        await new VerifyCS.Test
        {
            CompilerDiagnostics = CompilerDiagnostics.None,
            ReferenceFakeLogging = true,
            TestCode = "",
            TestState =
            {
                GeneratedSources =
                {
                    GetSourceFile(ExpectedFakeLoggingGeneratedFile, "AutoMockerFakeLoggingExtensions.g.cs")
                }
            }
        }.RunAsync();
    }

    [TestMethod]
    public async Task WhenGeneratorIsDisabled_NoGenerationOccurs()
    {
        var test = new VerifyCS.Test
        {
            ReferenceFakeLogging = true,
            TestCode = ""
        };
        test.SetGlobalOption("build_property.EnableMoqAutoMockerFakeLoggingGenerator", "false");
        await test.RunAsync();
    }

    [TestMethod]
    public async Task WhenGeneratorIsExplicitlyEnabled_ExtensionMethodIsGenerated()
    {
        var test = new VerifyCS.Test
        {
            CompilerDiagnostics = CompilerDiagnostics.None,
            ReferenceFakeLogging = true,
            TestCode = "",
            TestState =
            {
                GeneratedSources =
                {
                    GetSourceFile(ExpectedFakeLoggingGeneratedFile, "AutoMockerFakeLoggingExtensions.g.cs")
                }
            }
        };
        test.SetGlobalOption("build_property.EnableMoqAutoMockerFakeLoggingGenerator", "true");
        await test.RunAsync();
    }

    private static (string FileName, SourceText SourceText) GetSourceFile(string content, string fileName)
    {
        return (Path.Combine("Moq.AutoMocker.Generators", "Moq.AutoMocker.Generators.FakeLoggingExtensionSourceGenerator", fileName), SourceText.From(content, Encoding.UTF8));
    }
}
